/* -------오후수업*------------ */
/* 
가비지 컬렉터(Garbage Collector)
* C언어 - 개발자가 메모리 선언,할당, 데이터처리,메모리 삭제(반환)
* JAVA,C#,JS,Go - 메모리 관리해주는 GC(garbage Collector) 가짐
*동작시점 : 가비지콜렉터가 가지고있는 임계치에 도달하게되면 백그라운드에서 실행된다.
            (대상이 된다고 바로 동작/실행이 되는것은 아니다.)
*/

let apple = {
  name: "apple",
};

let orange = apple;
apple = null;
orange = null;
//gc의 대상은 ? memory heap 에 생성된 객체이다.

/* 
실행 컨텍스트(Execution context)
- 실행 순서와 스코프를 기억하고 있음
- 실행 컨텍스트는 스코프정보를 가지있는
렉시켤 환경 오브젝트를 생성하여 관리하며
렉시컬 환경 오브젝트는 각각의 스코프 체이닝으로 연결됨 
-코드 맨 안쪽의 블럭이 맨 먼저 생성됨


[스코프란 ?]
식별자(함수,변수,제어문)의 유효한 범위를 참조할 수 있는 {}블럭 단위로 구분 된 영역이다.
스코프는 이름 충돌 방지의 기능도 있지만 블럭이 끝나면 참조하는 값이 없어져 가비지컬렉터의 대상이 되므로,
스코프로 식별자의 범위를 제한하여 메모리 효율성을 높일 수 있다. 
스코프 내부의 식별자는 참조가 불가능하지만, 내부에서 외부스코프의 식별자는 참조가 가능합니다. 참조가 가능한 이유는 
실행컨텍스트에 있는 렉시컬 환경 오브젝트가 스코프단위로 정보를 기억하고 있으며 맨 안쪽에 생성되는 스코프 부터 체이닝을 이용하여 연결되어 있기 떄문입니다.
그래서 스코프를 사용할 때 메모리 절약과 성능을 고려한다면 식별자 선언과 사용은 필요한 블럭에서 정의하고 호출하도록 하는것이 좋다고 생각합니다.

<과제>
Hoisting, Closer , Prototype 알아오기

hoisting 호이스팅이란 ?
자바스크립트 코드는 인터프리터에 의해 한줄씩 순차적으로 실행된다. 
자바스크립트는 변수선언이 어디에 있든 코드를 실행한다.
변수가 선언되기전 참조코드가 먼저 실행된다면 참조 에러가 발생해야 하지만 undefine이 출력된다.
이처럼 변수의 선언이 코드의 선두로 끌어 올려진 것처럼 동작하는 자바스크립트의 특징을 호이스팅이라고 한다.

Closer 란?
이미 생명주기(life cycle)이 끝난 외부함수의 변수를 참조할때 이 외부함수를 클로저라고한다.?


*/
