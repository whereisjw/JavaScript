/* -------오후수업*------------ */
/* 
가비지 컬렉터(Garbage Collector)
* C언어 - 개발자가 메모리 선언,할당, 데이터처리,메모리 삭제(반환)
* JAVA,C#,JS,Go - 메모리 관리해주는 GC(garbage Collector) 가짐
*동작시점 : 가비지콜렉터가 가지고있는 임계치에 도달하게되면 백그라운드에서 실행된다.
            (대상이 된다고 바로 동작/실행이 되는것은 아니다.)
*/

let apple = {
  name: "apple",
};

let orange = apple;
apple = null;
orange = null;
//gc의 대상은 ? memory heap 에 생성된 객체이다.

/* 
실행 컨텍스트(Execution context)
- 실행 순서와 스코프를 기억하고 있음
- 실행 컨텍스트는 스코프정보를 가지있는
렉시켤 환경 오브젝트를 생성하여 관리하며
렉시컬 환경 오브젝트는 각각의 스코프 체이닝으로 연결됨 
-코드 맨 안쪽의 블럭이 맨 먼저 생성됨


[스코프란 ?]
식별자(함수,변수,제어문)의 유효한 범위를 참조할 수 있는 {}블럭 단위로 구분 된 영역이다.
스코프는 이름 충돌 방지의 기능도 있지만 블럭이 끝나면 참조하는 값이 없어져 가비지컬렉터의 대상이 되므로,
스코프로 식별자의 범위를 제한하여 메모리 효율성을 높일 수 있다. 
스코프 내부의 식별자는 참조가 불가능하지만, 내부에서 외부스코프의 식별자는 참조가 가능합니다. 참조가 가능한 이유는 
실행컨텍스트에 있는 렉시컬 환경 오브젝트가 스코프단위로 정보를 기억하고 있으며 맨 안쪽에 생성되는 스코프 부터 체이닝을 이용하여 연결되어 있기 떄문입니다.
그래서 스코프를 사용할 때 메모리 절약과 성능을 고려한다면 식별자 선언과 사용은 필요한 블럭에서 정의하고 호출하도록 하는것이 좋다고 생각합니다.

<과제>
Hoisting, Closer , Prototype 알아오기

hoisting 호이스팅이란 ?
자바스크립트 코드는 인터프리터에 의해 한줄씩 순차적으로 실행된다. 
자바스크립트는 변수선언이 어디에 있든 코드를 실행한다.
변수가 선언되기전 참조코드가 먼저 실행된다면 참조 에러가 발생해야 하지만 undefine이 출력된다.
이처럼 변수의 선언이 코드의 선두로 끌어 올려진 것처럼 동작하는 자바스크립트의 특징을 호이스팅이라고 한다.

Closer 란?
이미 생명주기(life cycle)이 끝난 외부함수의 변수를 참조할때 이 외부함수를 클로저라고한다.?
*/

/* 
5.호이스팅(Hoisting)
-자바스크립트 엔진(인터프리터)이 실행하기전에 변수,함수,클래스등을 최상단으로 끌어올리는 작업
-ES6 이전에는 변수 클래스는 호이스팅 작업시 선언과 초기화가 함께 진행되었으니, ES6 부터는 선언만 가능해짐
-ES6 기준으로 let,const 키워드가 등장함
-var는 되도록 사용x,let, const를 사용하여 명확한 프로그래밍 가능



6.var 특징
-다른 언어와 코딩 방식의(변수 할당등) 차이로 디버깅이 어려움
-코드의 가독성과 유지보수 측면에서 좋지 않음
1)변수 선언시 키워드가 없어도 사용 가능하므로 , 선언인지 재할당인지, 구분이 어려움
~~~
name = '홍길동'; --> var name = '홍길동';
~~~
2) 중복선언이 가능함

~~~
var person = "홍길동";
var person = "홍길순";
~~~

3)변수, 클래스는 블럭 단위  스코프가 안됨
~~~
var fruit = "apple"; 
{
  var fruit = "orange"; 
  console.log(fruit); // orange
}
console.log(fruit); // orange
~~~
4) 함수레벨 스코프는 지원됨
~~~
var test = "test";
function varTest() {
  var test = "test2";
  console.log(test);
}
console.log(test); //test
~~~
7.프로토타입 (Prototype)
- 자바스크립트에서 객체지향 적으로 프로그래밍을 하기 위해
  프로토타입이 제공되며, 공통적인 특징,기능,상태 등을
  저장하여 필요한 객체에게 상속을 통해 적용할 수 있다.
  -최상위 프로토타입(클래스)은 Object로 생성되는 모든 객체는 
  상속을 받아 구현된다.
*/
class Parent {
  constructor() {
    this.name = "부모";
  }
}
class Person extends Parent {
  constructor() {
    super();
    this.name = "hong";
    this.age = 20;
  }
}
hong = new Person();
